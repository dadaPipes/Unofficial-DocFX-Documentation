{
  "docs/project-overview.html": {
    "href": "docs/project-overview.html",
    "title": "Project Overview | Unofficial DocFX Documentation",
    "summary": "Project Overview Folder structure File Arrangement Script The script I use writes the physical file arrangement to a Markdown file. It captures the folder and file structure as it exists on disk. For now, I need to manually arrange folders to match the logical structure. Script Functionality The script writes all folders and files from its execution root to a Markdown file named filetree.md, placing it at the same root level. By default: Excluding bin and obj directories by default. Writes a header # Solution Structure. Creates a list with sublists of the directories including the files of the root path. Takes one argument that specify what file type to exclude. example: dotnet script MarkdownSolutionTreeGenerator.csx: Excluding bin and obj directories. dotnet script MarkdownSolutionTreeGenerator.csx -- \".cs\": Excluding bin and obj directories and all .cd files. dotnet script MarkdownSolutionTreeGenerator.csx -- \".*\": Excluding bin and obj directories and all files #r \"nuget: System.IO.Abstractions\" using System; using System.IO; using System.Linq; var rootPath = @\".\"; var outputPath = @\"filetree.md\"; // Read extensions to exclude from arguments, handling wildcard \".*\" var excludedExtensions = Args.Select(arg => arg == \".*\" ? string.Empty : arg).ToList(); using (var writer = new StreamWriter(outputPath)) { writer.WriteLine(\"# Solution Structure\"); writer.WriteLine(\"\"); TraverseDirectory(rootPath, writer, \"\"); } Console.WriteLine(\"Markdown file generated!\"); void TraverseDirectory(string path, StreamWriter writer, string indent) { foreach (var directory in Directory.GetDirectories(path)) { var dirName = Path.GetFileName(directory); // exclude bin and obj directories if (dirName == \"bin\" || dirName == \"obj\") continue; writer.WriteLine($\"{indent}- {dirName}\"); TraverseDirectory(directory, writer, indent + \" \"); } foreach (var file in Directory.GetFiles(path)) { var fileExtension = Path.GetExtension(file); // Skip files if extensions match the excluded list if (excludedExtensions.Contains(string.Empty) || excludedExtensions.Any(ext => fileExtension.Equals(ext, StringComparison.OrdinalIgnoreCase))) continue; writer.WriteLine($\"{indent}- {Path.GetFileName(file)}\"); } } Script output excluding all files #### Solution Structure - .vscode - docfx - Extensions - Models - Properties - Docfx.App - Build - Config - Helpers - Docfx.Build - ApiPage - Conceptual - PostProcessors - ResourceFileReaders - ResourceFiles - Settings - TableOfContents - TemplateProcessors - Preprocessors - ViewRenderers - XRefMaps - Docfx.Build.Common - ModelAttributeHandlers - Handlers - Reference - Docfx.Build.ManagedReference - BuildOutputs - Docfx.Build.OperationLevelRestApi - Docfx.Build.OverwriteDocuments - ExtendedModels - Models - Rules - Docfx.Build.RestApi - Swagger - Internals - JsonLocation - Docfx.Build.SchemaDriven - Exceptions - Models - Processors - Validators - Docfx.Build.TagLevelRestApi - Docfx.Build.UniversalReference - BuildOutputs - Docfx.Common - EntityMergers - Exceptions - FileAbstractLayer - Git - Json - NewtonsoftJson - System.Text.Json - Loggers - Path - ResourcePools - Docfx.DataContracts.Common - Attributes - ExternalReferences - Docfx.DataContracts.RestApi - Docfx.DataContracts.UniversalReference - Docfx.Dotnet - ExtensionMethods - Filters - ManagedReference - Models - Resolvers - Visitors - Parsers - Resources - SourceLink - Docfx.Glob - Docfx.MarkdigEngine - YamlHeader - Docfx.MarkdigEngine.Extensions - Aggregator - CodeSnippet - HeadingId - Inclusion - InclusionBlock - InclusionInline - InlineOnly - Interactive - LineNumber - MonikerRange - NestedColumn - Noloc - PlantUml - QuoteSectionNote - ResolveLink - Rewriter - Row - TabGroup - TripleColon - Xref - Docfx.Plugins - Docfx.YamlSerialization - Helpers - NodeDeserializers - NodeTypeResolvers - ObjectDescriptors - ObjectFactories - ObjectGraphTraversalStrategies - ObjectGraphVisitors - TypeInspectors Future plans Adapt the script to extract the logical file arrangement, reflecting how files are organized in Visual Studio's Solution Explorer. rootPath as an argument so I can use it in selected directories."
  },
  "index.html": {
    "href": "index.html",
    "title": "Introduction | Unofficial DocFX Documentation",
    "summary": "Introduction Overview I want to contribute to DocFX because I believe it has a lot of potential. Currently not supported: Versioning Diagrams from source code Include API links in the diagrams I have a some basic ideas of how I could implement the above features, but I will dive in to that on a later stage. For now I will figure out how the DocFX works internally, so I can contribute to the official project. Attack plan for DocFX What are the big moving parts ? How does the projects depend on each other ? What are the system boundaries and responsibilities ? How is each project build ? Structure, interfaces, dependencies ? Project boundary ? How is the flow ? How do a user interact with the system ? Where is there entry point ? What are the class/interface boundaries ? Flow between projects ?"
  }
}